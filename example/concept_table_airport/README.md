# Implementation of concept tables and multilingual concepts
This is a proposal implementation to handle:
- concept tables
- multilingual concepts

## Concept table 
A concept table is the possibility to handle the values of a dimension as a url to a new resource (a concept).  
This is similar to an object that is the URL of a Shared Dimension's term, but here the concepts are created for the cube and uploaded with the cube.  
Remark: if the resource/concept already exist, than the case is similar to the handling of Shared Dimensions mapping, and this is already handled by pyCube with the "mapping" mechanism.  

## This example's dataset
This example is a little dataset with values/measures about some airport types, the dataset in [data.csv](data.csv) and the airport types in [airportType.csv](airportType.csv).  
Each airport type is identified by two fields (`typeOfAirportID` + `typeOfAirportSecondID`), to demonstrate how to handle this use case that can easily happen in reality.  
But one field would have been enough here, and the example is easily adapted by removing the typeOfAirportSecondID from the configurations.

This example handles two tasks:
- Generate the correct URL for the dimension's object
- Generate the concepts with their properties

## Generate the correct URLs for the dimension's object
In description.yml, the "typeOfAirport" dimension is defined with the standards settings, plus the new mapping type:
```
	mapping:
		type: concept
		replacement: /airport_type/{typeOfAirport}/{typeOfAirport2nd}    
```

In the code, this is handled in the existing `_apply_mappings()` method, with new this `concept` mapping type.  

The replacement will generate a URL replacing for each line the values of the identifiers `{typeOfAirport}` and `{typeOfAirport2nd}`.  
- If the value starts with "/", as this example, it is considered a relative URL that will be concatenated to the cube's URL
- If the value do not start with "/", it should be a full URL also containing {field} values that are replaced on the fly.  

**Proposal 1**: this "replacement" handling could be also implement for shared dimensions.  
It could be added to the current "replacements" (with -s) handling, where this replacements allows to give a one-to-one mapping
that might be needed if no corresponding key exists to automatically build the URL (map "Zurich" to 0 for example).  

**Proposal 2**: maybe this way of handling the URL, with the {field} configuration, could replace the current "additive" and "replace" mappings type, handling both with one single syntax.

## Generate the concepts with their properties
This can be seen as another independant operation, to generate the triples for the concepts.  

The concept metadata are added to the "description.yml" as follow:
```
	Concepts:
		typeOfAirport:
			URI: /airport_type/{typeOfAirportID}/{typeOfAirportSecondID}
			name-field: typeOfAirport
			position-field: position
			multilingual: true 
```

A specific dataframe is created with the content of "airportTypes.csv", and added to the cube's graph with:
```
	cube.write_concept("typeOfAirport", airport_concept_df)
```
The first parameter is the key found under the "Concepts" in the yaml file  
The second is the dataframe with the values.  

The new method `cube.write_concept()` will generate the triples based on:  
- URI: Used to generate a URL replacing for each line the values of the identifiers `{typeOfAirportID}` and `{typeOfAirportSecondID}`      
The handling is similar to the "replacement" value for the dimension objects  
Both patterns should generate the same URLs, with the flexibility to have different column names in different files  
- name-field: (mandatory) the name of the csv column that contains the name for that concept used for schema:name  
- multilingual: (optional) if true, than the code will look for columns named name-field + the langage tags (_en, _de,_fr, etc)  
and generate the different schema:name language strings
- position-field: (optional) the name of the csv column that contains a numeric position value for the concept  
this will generate a `schema:position` that is used by Visualize when the concepts should not be displayed in alphabetical order but according to that position value

### Concept triples
The concept triples were deduced by observing some concepts generated by the Cube Creator.  
The current code generates the following triples
- no rdf:type, but this could be added
- the URL of the concept is based on the URL of the cube, with a version  
However, all those concepts "versions" have a `schema:sameAs` to the URL of the cube without the version (the use of that information might need clarification)
- schema:name is mandatory, and could be either a single value, or language strings to handle multilingual concepts (as in this example)
- schema:position, optional, see the explanation here above

Example result (see [cube_with_concept.ttl](cube_with_concept.ttl)):
```
	<https://mock-concept.ld.admin.ch/cube/mock-concept/1/concept/airport_type/A/a> schema1:name "Inlandflughafen"@de,
			"Domestic airport"@en,
			"Aéroport national"@fr ;
		schema1:position 1 ;
		schema1:sameAs <https://mock-concept.ld.admin.ch/cube/mock-concept/concept/airport_type/A/a> .  
```

### Checking the matchings
As we can see, the concepts triples are "separated" triples, not related to the cube itself, where the concept's URL should match the object URL of the dimension (explained here above).  

Different mismatch could happen if:
- The configuration of the URL mapping is not well defined, either in the dimension (`mapping/replacement` field) or in the concept (`URI` field)
- The configuration is correct, but the values in the two input files do not match

As a reminder: in RDF there is no enforcement of a resource to be explicitly defined for the RDF to be valid. This means that the object of the dimension could be a URL that is not defined anywhere else.  
Of course, this will break applicatons as Visualize, but it is still valid RDF (Open World Assumption).  

For this purpose, a `pycube.check_dimension_object_property()` method is added.
It is called in [example_concept.py](example_concept.py) as follow:  
```
allConceptsFound = cube.check_dimension_object_property("typeOfAirport", SCHEMA.name)
```
It means: check that all objects of the "typeOfAirport" dimension (defined in the .yaml file) point to a resource that does have a `schema:name` value. Knowing that concepts MUST HAVE a `schema:name` as explained here above.
That method will print out the URLs that have no match, and returns False if this is the case.  
In this example, there is a voluntary missing match for the line in [data.csv](data.csv):  
```
2001,A,dummy,15
```
Which will be the cause of the following log line:
```
Missing value for  https://mock-concept.ld.admin.ch/cube/mock-concept/1/concept/airport_type/A/dummy
```

IMPORTANT: `pycube.check_dimension_object_property()` will recreate the dimension's property URL based on the path `value`.  
The code comes from the existing `_add_observation()`, and if that code changes, it should be adapted here as well.
```
    dimension = self._get_shape_column(dimension_name) # raises an exception if dimension not found
    path = URIRef(self._base_uri + dimension.get("path"))
```	
## Additional fields for concepts
It is possible to add additional properties (fields) for a concept.

In the example, airportType.csv contains two more fields:
- description: a multilingual field to add a description for the airport type
- other_property_example: another string field as an example

Those fields are configured directly in the description.yml, for the concept itself:
```
	Concepts:
		typeOfAirport:
			URI: /airport_type/{typeOfAirportID}/{typeOfAirportSecondID}
			name-field: typeOfAirport
			position-field: position
			multilingual: true 
			other-fields:
				description:
					URI: http://schema.org/description
					multilingual: true
				other_property_example:
					URI: /airport_type/other_property_example   
```		
where:
- other-fields is optional and will be omitted if the concept has no other field
- key: the key of the field (`description`, `other_property_example`) must match the name of the field in the data file
- URI: the URI to use as the RDF property for that field. It is either a full URI as `http://schema.org/description` that will be used as-is,
or a relative path that starts with a "/" and that will be concatenated to the cube's URL, adding first a `/concept/prop` path.
`URI` was intentionally used instead of the common `path` key, as the behavior is currently different (handling of relative or full path)
But the behavior and the name of the field could be harmonized in all cases
- multilingual: optional and similar to the multilingual handling for the concept's name. If true, the code will look for columns named `key` + the langage tags (_en, _de,_fr, etc). In the given example, for `description`, it will look for `description_en`, `description_fr`, etc.

The data type is deduced by the current `pycube._sanitize_value()`, except when `multilingual` is true and the expected value is a string.

The RDF result is:
```
<https://mock-concept.ld.admin.ch/cube/mock-concept/1/concept/airport_type/A/a> schema1:name "Inlandflughafen"@de,
        "Domestic airport"@en,
        "Aéroport national"@fr ;
	schema1:description "Domestic airport description"@en,
        "Description de Aéroport national"@fr ;
    schema1:position 1 ;
    schema1:sameAs <https://mock-concept.ld.admin.ch/cube/mock-concept/concept/airport_type/A/a> ;
    ns1:other_property_example "another property example for domesctic airport" .
```	

##  Run the example
Run [example_concept.py](example_concept.py) that will generate the [cube_with_concept.ttl](cube_with_concept.ttl)

